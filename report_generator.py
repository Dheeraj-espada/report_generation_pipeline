# -*- coding: utf-8 -*-
"""report_generator

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wpT59sCo7bwGeOhkYDDVhTrQJz7VfTHD
"""

#!/usr/bin/env python3
"""
Enhanced Integrated Saliva Health Report Generator v6.0
Comprehensive multi-section report with advanced statistical analysis and ERR gates

Key Improvements:
- Integrated robust statistical scoring from batch_health_scorer2.py
- Enhanced disease risk panels with ERR gates
- Improved genus health weights integration
- Advanced percentile-based scoring
- Better statistical functions (MAD, robust percentiles)
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.patches import Circle, Rectangle
import os
import json
import tempfile
from datetime import datetime
from scipy.stats import zscore, entropy, median_abs_deviation  
from scipy.special import erf
from math import sqrt
import warnings
warnings.filterwarnings('ignore')

# ReportLab imports
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import mm, inch
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.enums import TA_LEFT, TA_CENTER, TA_RIGHT, TA_JUSTIFY
from reportlab.platypus import (
    BaseDocTemplate, Frame, PageTemplate, Paragraph, Spacer,
    Image, Table, TableStyle, PageBreak, KeepTogether
)


class EnhancedSalivaHealthReportGenerator:
    """Enhanced saliva health report generator with advanced statistical analysis"""

    def __init__(self, feature_table_path, taxonomy_path, metadata_path=None,
                 sample_id=None, health_weights_path=None,
                 genus_percentiles_path=None, reference_stats_path=None):
        self.feature_table_path = feature_table_path
        self.taxonomy_path = taxonomy_path
        self.metadata_path = metadata_path
        self.sample_id = sample_id
        self.health_weights_path = health_weights_path
        self.genus_percentiles_path = genus_percentiles_path
        self.reference_stats_path = reference_stats_path
        self.run_id = None
        self.plots_dir = "temp_plots"
        os.makedirs(self.plots_dir, exist_ok=True)

        # Set matplotlib style for clean plots
        plt.style.use('seaborn-v0_8-whitegrid')
        sns.set_palette("husl")

        # Load data and perform analysis
        self.load_data()
        self.load_health_weights()
        self.load_genus_percentiles()
        self.load_reference_stats()

        # Advanced disease risk panels with ERR gates
        self.disease_panels = self.get_disease_risk_panels()

        self.health_analysis = self.perform_comprehensive_health_analysis()

        # Create comprehensive plots
        self.create_comprehensive_plots()

    def load_data(self):
        """Load and process data files"""
        try:
            print(f"📊 Loading feature table: {self.feature_table_path}")
            self.feature_table = pd.read_csv(self.feature_table_path, sep='\t', skiprows=1, index_col=0)
            print(f"   Shape: {self.feature_table.shape}")

            print(f"🔬 Loading taxonomy: {self.taxonomy_path}")
            self.taxonomy = pd.read_csv(self.taxonomy_path, sep='\t', index_col=0)
            print(f"   Shape: {self.taxonomy.shape}")

            if self.metadata_path and os.path.exists(self.metadata_path):
                print(f"📋 Loading metadata: {self.metadata_path}")
                self.metadata = pd.read_csv(self.metadata_path, sep='\t', index_col=0)
                print(f"   Shape: {self.metadata.shape}")

                if 'Run' in self.metadata.columns and self.sample_id in self.metadata.index:
                    self.run_id = self.metadata.loc[self.sample_id, 'Run']
                    print(f"   ✅ Mapped {self.sample_id} -> {self.run_id}")

            if not self.run_id:
                if self.sample_id in self.feature_table.columns:
                    self.run_id = self.sample_id
                else:
                    self.run_id = self.feature_table.columns[0]
                    self.sample_id = self.run_id
                print(f"   🎯 Using first sample: {self.sample_id}")

        except Exception as e:
            print(f"❌ Error loading data: {e}")
            raise e

    def load_health_weights(self):
        """Load genus health weights with enhanced error handling"""
        try:
            if self.health_weights_path and os.path.exists(self.health_weights_path):
                print(f"⚖️  Loading health weights: {self.health_weights_path}")
                weights_df = pd.read_csv(self.health_weights_path)

                if 'HealthWeight' in weights_df.columns and 'Genus' in weights_df.columns:
                    self.genus_weights = dict(zip(weights_df['Genus'], weights_df['HealthWeight']))
                elif 'Health_Weight' in weights_df.columns and 'Genus' in weights_df.columns:
                    self.genus_weights = dict(zip(weights_df['Genus'], weights_df['Health_Weight']))
                else:
                    print(f"   ❌ Expected columns not found in {weights_df.columns}")
                    self.genus_weights = self.get_default_genus_weights()

                print(f"   ✅ Loaded {len(self.genus_weights)} genus weights")
            else:
                print("⚠️  No health weights file found, using default weights")
                self.genus_weights = self.get_default_genus_weights()

        except Exception as e:
            print(f"❌ Error loading health weights: {e}")
            self.genus_weights = self.get_default_genus_weights()

    def load_genus_percentiles(self):
        """Load genus percentiles for robust scoring"""
        try:
            if self.genus_percentiles_path and os.path.exists(self.genus_percentiles_path):
                print(f"📊 Loading genus percentiles: {self.genus_percentiles_path}")
                with open(self.genus_percentiles_path, 'r') as f:
                    self.genus_percentiles = json.load(f)
                print(f"   ✅ Loaded percentiles for {len(self.genus_percentiles)} genera")
            else:
                print("⚠️  No genus percentiles file found, using defaults")
                self.genus_percentiles = {}
        except Exception as e:
            print(f"❌ Error loading genus percentiles: {e}")
            self.genus_percentiles = {}

    def load_reference_stats(self):
        """Load reference statistics for robust scoring"""
        try:
            if self.reference_stats_path and os.path.exists(self.reference_stats_path):
                print(f"📈 Loading reference stats: {self.reference_stats_path}")
                with open(self.reference_stats_path, 'r') as f:
                    self.reference_stats = json.load(f)
                print(f"   ✅ Loaded reference statistics")
            else:
                print("⚠️  No reference stats file found, using defaults")
                self.reference_stats = self.get_default_reference_stats()
        except Exception as e:
            print(f"❌ Error loading reference stats: {e}")
            self.reference_stats = self.get_default_reference_stats()

    def get_default_reference_stats(self):
        """Default reference statistics for key metrics"""
        return {
            'shannon': {'median': 2.8, 'mad': 0.4, 'mean': 2.9, 'std': 0.6},
            'bp_log_ratio': {'median': 0.2, 'mad': 0.3, 'mean': 0.1, 'std': 0.5},
            'scfa': {'median': 0.08, 'mad': 0.03, 'mean': 0.09, 'std': 0.05},
            'pathogen_load': {'median': 0.15, 'mad': 0.08, 'mean': 0.16, 'std': 0.12}
        }

    def get_disease_risk_panels(self):
        """Enhanced disease risk panels with ERR gates"""
        return [
            {
                "name": "Oral Cancer (OSCC)",
                "threshold": 0.05,
                "genera": [
                    {"name": "Fusobacterium", "w": 1.0},
                    {"name": "Peptostreptococcus", "w": 0.3}
                ],
                "all_of_percentile": {"Fusobacterium": "p97_5"},
                "any_of_percentile": {"Peptostreptococcus": "p90"}
            },
            {
                "name": "Periodontitis (Red Complex)",
                "threshold": 0.02,
                "genera": [
                    {"name": "Porphyromonas", "w": 0.5},
                    {"name": "Tannerella", "w": 0.5},
                    {"name": "Treponema", "w": 0.5}
                ],
                "at_least_k": {
                    "label": "p90",
                    "genera": ["Porphyromonas", "Tannerella", "Treponema"],
                    "k": 2
                }
            },
            {
                "name": "Halitosis (VSC)",
                "threshold": 0.01,
                "genera": [
                    {"name": "Solobacterium", "w": 1.0},
                    {"name": "Fusobacterium", "w": 0.5}
                ],
                "any_of_percentile": {"Solobacterium": "p90"}
            },
            {
                "name": "Dental Caries",
                "threshold": 0.03,
                "genera": [
                    {"name": "Lactobacillus", "w": 0.6},
                    {"name": "Scardovia", "w": 0.4},
                    {"name": "Streptococcus", "w": 0.5}
                ],
                "any_of_percentile": {"Lactobacillus": "p90", "Scardovia": "p90"}
            },
            {
                "name": "Systemic Inflammation Link",
                "threshold": 0.05,
                "genera": [
                    {"name": "Prevotella", "w": 0.5},
                    {"name": "Campylobacter", "w": 0.5}
                ],
                "any_of_percentile": {"Prevotella": "p97_5", "Campylobacter": "p90"}
            }
        ]

    def robust_percentile(self, x: float, stats: dict) -> float:
        """Compute robust percentile using MAD (Median Absolute Deviation)"""
        if 'median' in stats and 'mad' in stats and stats['mad'] not in [None, 0]:
            # Use MAD for robust z-score
            z = 0.6745 * (x - stats['median']) / stats['mad']
        else:
            # Fall back to mean/std
            sd = stats.get('std', 1.0) or 1.0
            z = (x - stats.get('mean', 0.0)) / sd

        # Convert to percentile
        p = 50 + (1 + erf(z / sqrt(2))) * 50
        return float(np.clip(p, 0, 100))

    def safe_log_ratio(self, a: float, b: float, eps: float = 1e-6) -> float:
        """Compute log ratio with epsilon to handle zeros"""
        return float(np.log((a + eps) / (b + eps)))

    def exceeds_abundance(self, abundances, genus, label):
    # convert p975 → p97_5
        lookup_label = label.replace('p975', 'p97_5')
        genus_data = self.genus_percentiles.get(genus, {})
    # try original label, then normalized
        threshold = genus_data.get(label)
        if threshold is None:
            threshold = genus_data.get(lookup_label)
        if threshold is None:
            return False
        return abundances.get(genus, 0) > float(threshold)

    def pass_err_gates(self, abundances: pd.Series, panel: dict) -> bool:
        """Check if sample passes all ERR gates for this panel"""
        # Check all_of_percentile: ALL specified genera must exceed their percentile
        all_map = panel.get("all_of_percentile", {})
        if all_map:
            if not all(self.exceeds_abundance(abundances, g, lbl) for g, lbl in all_map.items()):
                return False

        # Check any_of_percentile: AT LEAST ONE must exceed
        any_map = panel.get("any_of_percentile", {})
        if any_map:
            if not any(self.exceeds_abundance(abundances, g, lbl) for g, lbl in any_map.items()):
                return False

        # Check at_least_k: At least K out of N genera must exceed
        ak = panel.get("at_least_k")
        if ak:
            label = ak["label"]
            genera = ak["genera"]
            k = int(ak.get("k", len(genera)))
            hits = sum(self.exceeds_abundance(abundances, g, label) for g in genera)
            if hits < k:
                return False

        return True

    def calculate_panel_score(self, abundances: pd.Series, panel: dict) -> tuple[float, bool]:
        """Calculate weighted panel score and check if threshold exceeded"""
        score = 0.0
        for item in panel.get("genera", []):
            genus = item["name"]
            weight = float(item.get("w", 1.0))
            abundance = float(abundances.get(genus, 0.0))
            score += abundance * weight

        threshold = float(panel.get("threshold", 0.0))
        return score, score > threshold

    def get_default_genus_weights(self):
        """Enhanced default genus health weights based on literature"""
        return {
            # Beneficial genera (positive weights)
            'Streptococcus': 0.45, 'Neisseria': 0.40, 'Rothia': 0.35, 'Haemophilus': 0.30,
            'Granulicatella': 0.25, 'Actinomyces': 0.20, 'Gemella': 0.15, 'Corynebacterium': 0.10,
            'Veillonella': 0.25,  # SCFA producer

            # Pathogenic genera (negative weights)
            'Fusobacterium': -0.60, 'Prevotella': -0.45, 'Porphyromonas': -0.50,
            'Treponema': -0.55, 'Tannerella': -0.40, 'Peptostreptococcus': -0.35,
            'Parvimonas': -0.30, 'Selenomonas': -0.25, 'Capnocytophaga': -0.20,
            'Campylobacter': -0.35, 'Solobacterium': -0.45
        }

    def calculate_genus_abundances(self):
        """Calculate genus-level abundances for the sample"""
        try:
            if self.run_id not in self.feature_table.columns:
                print(f"⚠️  Sample {self.run_id} not found, using first sample")
                self.run_id = self.feature_table.columns[0]

            sample_data = self.feature_table[self.run_id]
            genus_counts = {}
            total_counts = 0

            for feature_id, count in sample_data.items():
                if feature_id in self.taxonomy.index and count > 0:
                    taxonomy_string = self.taxonomy.loc[feature_id, 'Taxon']

                    # Extract genus from taxonomy string
                    genus = None
                    for level in taxonomy_string.split(';'):
                        if level.strip().startswith('g__') and len(level.strip()) > 3:
                            genus = level.strip()[3:]
                            break

                    if genus and genus != '':
                        genus_counts[genus] = genus_counts.get(genus, 0) + count
                        total_counts += count

            if total_counts > 0:
                genus_abundances = {genus: count/total_counts
                                  for genus, count in genus_counts.items()}
                result = dict(sorted(genus_abundances.items(), key=lambda x: x[1], reverse=True))
                print(f"   ✅ Calculated {len(result)} genus abundances")
                return pd.Series(result)

            return pd.Series({})

        except Exception as e:
            print(f"❌ Error calculating genus abundances: {e}")
            return pd.Series({})

    def perform_comprehensive_health_analysis(self):
        """Perform comprehensive health analysis with advanced statistics"""
        genus_abundances = self.calculate_genus_abundances()

        if genus_abundances.empty:
            print("⚠️  Using mock data for testing")
            genus_abundances = self.get_mock_genus_abundances()

        # Calculate diversity metrics
        shannon_diversity = self.calculate_shannon_diversity(genus_abundances)
        simpson_diversity = self.calculate_simpson_diversity(genus_abundances)

        # Calculate health-related metrics
        beneficial_abundance = sum(genus_abundances.get(genus, 0)
                                 for genus in self.genus_weights
                                 if self.genus_weights[genus] > 0)

        pathogen_abundance = sum(genus_abundances.get(genus, 0)
                               for genus in self.genus_weights
                               if self.genus_weights[genus] < 0)

        # Safe log ratio for compositional data
        bp_log_ratio = self.safe_log_ratio(beneficial_abundance, pathogen_abundance)

        # SCFA producers
        scfa_producers = ['Veillonella', 'Prevotella', 'Eubacterium', 'Propionibacterium', 'Megasphaera']
        scfa_abundance = sum(genus_abundances.get(genus, 0) for genus in scfa_producers)

        # Inflammatory markers
        inflammatory_genera = ['Porphyromonas', 'Tannerella', 'Treponema']
        inflammatory_load = sum(genus_abundances.get(genus, 0) for genus in inflammatory_genera)

        # Calculate robust component scores using reference statistics
        component_scores = self.calculate_robust_component_scores(
            shannon_diversity, bp_log_ratio, scfa_abundance, pathogen_abundance
        )

        # Calculate clinical health index
        clinical_health_index = self.calculate_clinical_health_index(component_scores)

        # Determine health category
        health_category = self.determine_health_category(clinical_health_index)

        # Advanced disease risk assessment with ERR gates
        disease_risks = self.assess_disease_risks_with_err(genus_abundances)

        # Create comprehensive analysis
        analysis = {
            'sample_id': self.sample_id,
            'run_id': self.run_id,
            'timestamp': datetime.now().isoformat(),
            'clinical_health_index': clinical_health_index,
            'health_category': health_category,
            'key_metrics': {
                'shannon_diversity': shannon_diversity,
                'simpson_diversity': simpson_diversity,
                'beneficial_pathogen_log_ratio': bp_log_ratio,
                'scfa_producer_abundance': scfa_abundance,
                'pathogen_load': pathogen_abundance,
                'beneficial_abundance': beneficial_abundance,
                'inflammatory_load': inflammatory_load
            },
            'component_scores': component_scores,
            'raw_abundances': genus_abundances.to_dict(),
            'genus_weights': self.genus_weights,
            'disease_risks': disease_risks,
            'scfa_producers': scfa_producers,
            'inflammatory_genera': inflammatory_genera,
            'algorithm_version': 'SalivaDB Evidence-Based v6.0',
            'total_genera': len(genus_abundances),
            'total_asvs': len(self.feature_table),
            'err_gates_applied': True
        }

        print(f"✅ Advanced health analysis completed")
        print(f"   Clinical Health Index: {clinical_health_index:.2f}")
        print(f"   Health Category: {health_category}")
        print(f"   Disease risks detected: {len(disease_risks)}")

        return analysis

    def calculate_robust_component_scores(self, shannon, bp_log_ratio, scfa_abundance, pathogen_load):
        """Calculate component scores using robust statistics"""

        # Use robust percentile scoring
        shannon_score = self.robust_percentile(shannon, self.reference_stats.get('shannon', {}))
        ratio_score = self.robust_percentile(bp_log_ratio, self.reference_stats.get('bp_log_ratio', {}))
        scfa_score = self.robust_percentile(scfa_abundance, self.reference_stats.get('scfa', {}))
        pathogen_score = 100 - self.robust_percentile(pathogen_load, self.reference_stats.get('pathogen_load', {}))

        # Weighted composite score
        weights = {'shannon': 0.25, 'ratio': 0.30, 'scfa': 0.20, 'pathogen': 0.25}
        composite = (shannon_score * weights['shannon'] +
                    ratio_score * weights['ratio'] +
                    scfa_score * weights['scfa'] +
                    pathogen_score * weights['pathogen'])

        return {
            'shannon_score': round(shannon_score, 1),
            'ratio_score': round(ratio_score, 1),
            'scfa_score': round(scfa_score, 1),
            'pathogen_score': round(pathogen_score, 1),
            'composite_score': round(composite, 1)
        }

    def assess_disease_risks_with_err(self, genus_abundances):
        """Assess disease risks using ERR gates"""
        risks = {}

        for panel in self.disease_panels:
            # First check ERR gates
            if not self.pass_err_gates(genus_abundances, panel):
                continue

            # Calculate panel score and check threshold
            score, threshold_exceeded = self.calculate_panel_score(genus_abundances, panel)

            if threshold_exceeded:
                panel_threshold = panel.get('threshold', 0.0)
                risk_level = 'High' if score > 2 * panel_threshold else 'Moderate'

                # Get marker genera for this panel
                marker_genera = [g['name'] for g in panel.get('genera', [])]

                risks[panel['name']] = {
                    'panel_score': round(score, 4),
                    'threshold': panel_threshold,
                    'level': risk_level,
                    'marker': f"Elevated: {', '.join(marker_genera)}",
                    'err_gates_passed': True
                }

        return risks

    # Keep all the existing methods for diversity calculation, plotting, etc.
    # [Previous methods remain the same - calculate_shannon_diversity, calculate_simpson_diversity, etc.]
    def get_mock_genus_abundances(self):
        """Mock genus abundances for testing"""
        if 'T' in str(self.sample_id):  # OSCC samples
            return pd.Series({
                'Fusobacterium': 0.183, 'Rothia': 0.165, 'Prevotella': 0.124,
                'Veillonella': 0.098, 'Streptococcus': 0.087, 'Neisseria': 0.065,
                'Haemophilus': 0.054, 'Granulicatella': 0.043, 'Actinomyces': 0.032,
                'Gemella': 0.025, 'Porphyromonas': 0.035, 'Treponema': 0.028
            })
        else:  # Healthy samples
            return pd.Series({
                'Streptococcus': 0.245, 'Neisseria': 0.198, 'Rothia': 0.156,
                'Haemophilus': 0.134, 'Veillonella': 0.087, 'Granulicatella': 0.065,
                'Actinomyces': 0.043, 'Gemella': 0.032, 'Corynebacterium': 0.025,
                'Fusobacterium': 0.015
            })

    def calculate_shannon_diversity(self, abundances):
        """Calculate Shannon diversity index"""
        if abundances.empty:
            return 0.0

        # Filter out zero abundances
        filtered_abundances = abundances[abundances > 0]
        if filtered_abundances.empty:
            return 0.0

        # Calculate Shannon diversity
        shannon = entropy(filtered_abundances, base=np.e)
        return float(shannon)

    def calculate_simpson_diversity(self, abundances):
        """Calculate Simpson diversity index"""
        if abundances.empty:
            return 0.0

        total = abundances.sum()
        if total == 0:
            return 0.0

        # Normalize
        proportions = abundances / total
        simpson = 1 - sum(proportions**2)
        return float(simpson)

    def calculate_clinical_health_index(self, component_scores):
        """Calculate clinical health index using piecewise interpolation"""
        composite_score = component_scores['composite_score']

        # Piecewise linear interpolation (p5, p50, p95) -> (-5, 0, +5)
        x_points = [35.0, 50.0, 70.0]
        y_points = [-5.0, 0.0, 5.0]

        chi = float(np.clip(np.interp(composite_score, x_points, y_points), -10, 10))
        return round(chi, 2)

    def determine_health_category(self, clinical_index):
        """Determine health category from clinical index"""
        if clinical_index >= 3:
            return 'Excellent'
        elif clinical_index >= 1:
            return 'Good'
        elif clinical_index >= -1:
            return 'Average'
        elif clinical_index >= -3:
            return 'Below Average'
        else:
            return 'Non-Ideal'

    def create_comprehensive_plots(self):
        """Create comprehensive plots for the report"""
        abundances = self.health_analysis['raw_abundances']

        # Convert dict to pandas Series if needed
        if isinstance(abundances, dict):
            abundances = pd.Series(abundances)

        # 1. Enhanced composition chart
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
        fig.suptitle(f'Comprehensive Microbiome Analysis - {self.sample_id}',
                     fontsize=20, fontweight='bold', y=0.95)

        # Pie chart - Top 10
        top_10 = abundances.head(10)
        colors_pie = plt.cm.Set3(np.linspace(0, 1, len(top_10)))
        wedges, texts, autotexts = ax1.pie(
            top_10.values,
            labels=[f"{genus}" for genus in top_10.index],
            autopct='%1.1f%%',
            colors=colors_pie,
            startangle=90
        )
        ax1.set_title('Top 10 Genera Distribution', fontweight='bold', pad=20)

        # Bar chart - Top 15
        top_15 = abundances.head(15)
        colors_bar = ['#28a745' if genus in self.genus_weights and self.genus_weights[genus] > 0
                      else '#dc3545' if genus in self.genus_weights and self.genus_weights[genus] < 0
                      else '#6c757d' for genus in top_15.index]

        bars = ax2.barh(top_15.index, top_15.values, color=colors_bar, alpha=0.8)
        ax2.set_title('Top 15 Genera Abundances', fontweight='bold', pad=20)
        ax2.set_xlabel('Relative Abundance')

        # Health profile classification
        beneficial = sum(abundances.get(g, 0) for g in self.genus_weights if self.genus_weights[g] > 0)
        pathogenic = sum(abundances.get(g, 0) for g in self.genus_weights if self.genus_weights[g] < 0)
        neutral = 1 - beneficial - pathogenic

        categories = ['Beneficial', 'Pathogenic', 'Neutral']
        values = [beneficial, pathogenic, neutral]
        colors_health = ['#28a745', '#dc3545', '#6c757d']

        bars = ax3.bar(categories, values, color=colors_health, alpha=0.8)
        ax3.set_title('Health Profile Classification', fontweight='bold', pad=20)
        ax3.set_ylabel('Relative Abundance')

        # Diversity comparison
        sample_diversity = self.health_analysis['key_metrics']['shannon_diversity']
        reference_diversity = 3.2
        diversity_data = ['Your Sample', 'Healthy Reference']
        diversity_values = [sample_diversity, reference_diversity]
        colors_div = ['#2E86AB', '#A23B72']

        bars = ax4.bar(diversity_data, diversity_values, color=colors_div, alpha=0.8)
        ax4.set_title('Shannon Diversity Comparison', fontweight='bold', pad=20)
        ax4.set_ylabel('Shannon Diversity Index')

        plt.tight_layout()
        self.composition_plot = os.path.join(self.plots_dir, f"{self.sample_id}_composition.png")
        plt.savefig(self.composition_plot, dpi=300, bbox_inches='tight',
                    facecolor='white', edgecolor='none')
        plt.close()

        # 2. Enhanced scoring visualization
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 10))
        fig.suptitle(f'Health Scoring Analysis - {self.sample_id}',
                     fontsize=20, fontweight='bold', y=0.95)

        # Component scores
        components = ['Shannon\nDiversity', 'Beneficial/Pathogen\nRatio', 'SCFA\nProducers', 'Pathogen\nControl']
        scores = [
            self.health_analysis['component_scores']['shannon_score'],
            self.health_analysis['component_scores']['ratio_score'],
            self.health_analysis['component_scores']['scfa_score'],
            self.health_analysis['component_scores']['pathogen_score']
        ]

        colors_comp = ['#28a745' if s >= 70 else '#ffc107' if s >= 40 else '#dc3545' for s in scores]
        bars = ax1.bar(components, scores, color=colors_comp, alpha=0.8)
        ax1.set_title('Component Scores (0-100)', fontweight='bold', pad=15)
        ax1.set_ylabel('Score')
        ax1.set_ylim(0, 100)

        # Add value labels
        for bar, score in zip(bars, scores):
            height = bar.get_height()
            ax1.text(bar.get_x() + bar.get_width()/2., height + 2,
                    f'{score:.0f}', ha='center', va='bottom', fontweight='bold')

        # Clinical index gauge
        clinical_index = self.health_analysis['clinical_health_index']
        theta = np.linspace(0, np.pi, 100)
        radius = 1

        # Draw gauge background
        ax2.plot(radius * np.cos(theta), radius * np.sin(theta), 'k-', linewidth=3)

        # Color segments
        segments = [(-10, -3, '#dc3545'), (-3, -1, '#ffc107'), (-1, 1, '#17a2b8'), (1, 3, '#28a745'), (3, 10, '#20c997')]
        for start, end, color in segments:
            start_angle = np.pi * (1 - (start + 10) / 20)
            end_angle = np.pi * (1 - (end + 10) / 20)
            angles = np.linspace(start_angle, end_angle, 20)
            ax2.plot(radius * np.cos(angles), radius * np.sin(angles), color=color, linewidth=6)

        # Add needle
        needle_angle = np.pi * (1 - (clinical_index + 10) / 20)
        ax2.arrow(0, 0, 0.8 * np.cos(needle_angle), 0.8 * np.sin(needle_angle),
                 head_width=0.05, head_length=0.05, fc='black', ec='black')

        ax2.set_xlim(-1.2, 1.2)
        ax2.set_ylim(-0.2, 1.2)
        ax2.set_aspect('equal')
        ax2.set_title(f'Clinical Health Index: {clinical_index:.2f}', fontweight='bold', pad=15)
        ax2.text(0, -0.1, f'{self.health_analysis["health_category"]}', ha='center', va='center',
                fontsize=12, fontweight='bold')
        ax2.axis('off')

        # Metrics radar chart
        metrics = ['Shannon\nDiversity', 'B/P Ratio', 'SCFA\nProducers', 'Pathogen\nControl']
        values_radar = scores + [scores[0]]  # Complete the circle
        angles = np.linspace(0, 2*np.pi, len(metrics), endpoint=False)
        angles = np.concatenate((angles, [angles[0]]))

        ax3.plot(angles, values_radar, 'o-', linewidth=2, color='#2E86AB')
        ax3.fill(angles, values_radar, alpha=0.25, color='#2E86AB')
        ax3.set_xticks(angles[:-1])
        ax3.set_xticklabels(metrics)
        ax3.set_ylim(0, 100)
        ax3.set_title('Health Metrics Radar', fontweight='bold', pad=15)
        ax3.grid(True)

        # Risk assessment
        risks = list(self.health_analysis['disease_risks'].keys())
        risk_levels = [self.health_analysis['disease_risks'][risk]['level'] for risk in risks]

        if risks:
            risk_colors = ['#dc3545' if level == 'High' else '#ffc107' for level in risk_levels]
            bars = ax4.barh(risks, [1]*len(risks), color=risk_colors, alpha=0.8)
            ax4.set_title('Disease Risk Assessment', fontweight='bold', pad=15)
            ax4.set_xlabel('Risk Level')
        else:
            ax4.text(0.5, 0.5, 'No significant\ndisease risks detected',
                    ha='center', va='center', transform=ax4.transAxes,
                    fontsize=14, fontweight='bold', color='#28a745')
            ax4.set_title('Disease Risk Assessment', fontweight='bold', pad=15)
            ax4.axis('off')

        plt.tight_layout()
        self.scoring_plot = os.path.join(self.plots_dir, f"{self.sample_id}_scoring.png")
        plt.savefig(self.scoring_plot, dpi=300, bbox_inches='tight',
                    facecolor='white', edgecolor='none')
        plt.close()

        print(f"✅ Created comprehensive plots: {self.composition_plot}, {self.scoring_plot}")


    def generate_comprehensive_report(self):
        """Generate comprehensive PDF report"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        report_name = f"{self.sample_id}_Enhanced_Report_{timestamp}.pdf"

        try:
            print(f"🔄 Generating enhanced comprehensive report: {report_name}")

            # Use ReportLab to create PDF (keeping existing implementation)
            doc = BaseDocTemplate(
                report_name,
                pagesize=A4,
                leftMargin=20*mm,
                rightMargin=20*mm,
                topMargin=25*mm,
                bottomMargin=25*mm
            )

            frame = Frame(
                doc.leftMargin,
                doc.bottomMargin,
                doc.width,
                doc.height,
                id='normal',
                leftPadding=6*mm,
                rightPadding=6*mm,
                topPadding=6*mm,
                bottomPadding=6*mm
            )

            doc.addPageTemplates([PageTemplate(id='main', frames=frame)])

            # Create enhanced styles
            styles = getSampleStyleSheet()
            styles.add(ParagraphStyle(
                name='MednovaTitle',
                parent=styles['Heading1'],
                fontSize=24,
                spaceAfter=30,
                alignment=TA_CENTER,
                textColor=colors.HexColor('#2E86AB')
            ))

            # Build story with all sections
            story = []

            # Executive Summary
            story.append(Paragraph("MEDNOVA DIAGNOSTICS", styles['MednovaTitle']))
            story.append(Paragraph("Enhanced Saliva Microbiome Health Analysis v6.0", styles['MednovaTitle']))
            story.append(Spacer(1, 20*mm))

            # Summary information
            summary_text = f"""
            Sample ID: {self.health_analysis['sample_id']}
            Clinical Health Index: {self.health_analysis['clinical_health_index']:.2f}/10
            Health Category: {self.health_analysis['health_category']}

            Key Enhancements:
            • ERR (Early Risk Recognition) gates applied
            • Robust statistical scoring with MAD
            • Advanced disease risk panels
            • Evidence-based genus weights

            Analysis completed using {self.health_analysis['algorithm_version']}
            """

            story.append(Paragraph(summary_text, styles['Normal']))

            # Add composition plot if available
            if hasattr(self, 'composition_plot') and os.path.exists(self.composition_plot):
                story.append(PageBreak())
                story.append(Paragraph("Microbiome Composition Analysis", styles['Heading1']))
                story.append(Image(self.composition_plot, width=170*mm, height=120*mm))

            # Add scoring plot if available
            if hasattr(self, 'scoring_plot') and os.path.exists(self.scoring_plot):
                story.append(PageBreak())
                story.append(Paragraph("Health Scoring Analysis", styles['Heading1']))
                story.append(Image(self.scoring_plot, width=170*mm, height=100*mm))

            # Disease Risk Assessment
            story.append(PageBreak())
            story.append(Paragraph("Enhanced Disease Risk Assessment", styles['Heading1']))

            if self.health_analysis['disease_risks']:
                risk_text = "The following disease risks have been identified using advanced ERR gates:\n\n"
                for disease, risk_info in self.health_analysis['disease_risks'].items():
                    risk_text += f"• {disease}: {risk_info['level']} Risk\n"
                    risk_text += f"  Score: {risk_info['panel_score']:.4f}\n"
                    risk_text += f"  {risk_info['marker']}\n\n"
            else:
                risk_text = "No significant disease risks detected. All ERR gates passed successfully."

            story.append(Paragraph(risk_text, styles['Normal']))

            # Build the PDF
            doc.build(story)

            print(f"✅ Enhanced comprehensive report generated: {report_name}")
            return report_name

        except Exception as e:
            print(f"❌ Error generating report: {e}")
            import traceback
            traceback.print_exc()
            return None


if __name__ == "__main__":
    # Generate enhanced comprehensive report
    generator = EnhancedSalivaHealthReportGenerator(
        feature_table_path="feature-table.tsv",
        taxonomy_path="taxonomy.tsv",
        metadata_path="metadata_saliva.tsv",
        sample_id="SalivaT4",
        health_weights_path="salivadb_genus_weights.csv",
        genus_percentiles_path="genus_percentiles.json",
        reference_stats_path="reference_stats.json"
    )

    report_path = generator.generate_comprehensive_report()
    if report_path:
        print(f"✅ Enhanced comprehensive report generated: {report_path}")
        print("\n🚀 Key enhancements implemented:")
        print("   • ERR (Early Risk Recognition) gates")
        print("   • Robust statistical scoring")
        print("   • Advanced disease risk panels")
        print("   • MAD-based percentile calculations")
        print("   • Enhanced error handling")
